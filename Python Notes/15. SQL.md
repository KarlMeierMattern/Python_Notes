# SQL  

## Intro to SQL  
- SQL is the language used to create/modify and extract data from a relational database.  
- A relational database is a collection of data organized into tables (of rows and columns/fields).  

    SELECT name, birthdate
    FROM people;

> Name refers to the column in the file and people refers to the table in the database.  
> `SELECT` and `FROM` are keywords.  
> They are not case sensitive but good practice to capitalize for readability.  
> Semicolon tells SQL where the query ends.  

    SELECT *
    FROM people
    LIMIT 10;

> `*` returns all columns in the table.  
> LIMIT returns a specified number of rows.  

    SELECT DISTINCT name
    FROM people;

> `DISTINCT` returns unique elements in a column.  

    SELECT COUNT(*)
    FROM people;

> `COUNT(*)` counts the number of rows in the table.  

    SELECT COUNT(birthdate)
    FROM people;

> `COUNT(birthdate)` counts the number of non-missing rows in the birthdate column of the people table.  

    SELECT COUNT(DISTINCT birthdate)
    FROM people;

> `COUNT(DISTINCT birthdate)` counts the number of unique rows in the birthdate column of the people table.  

## WHERE keyword  
- In SQL, the `WHERE` keyword allows you to filter based on both text and numeric values in a table.  
- The `WHERE` clause always comes after the `FROM` statement.  

### Comparison operators  
- `=` equal  
- `<>` not equal (!= is syntax for Python)  
-	`<` less than  
-	`>` greater than  
-	`<=` less than or equal to  
-	`>=` greater than or equal to  

    SELECT name, birthdate
    FROM people
    WHERE birthdate = ‘1974-11-11’

> Finds the name and birthdate of the person born on 11/11/1974.  

    SELECT *
    FROM films
    WHERE language = ‘Spanish’
    AND release_year > 2000
    AND release_year < 2010

> Gets all the details of Spanish language films released after the year 2000 but before 2010.  

## AND and OR keywords  
- When combining `AND` and `OR`, be sure to enclose the individual clauses in parentheses.  
- Otherwise, due to SQL's precedence rules, you may not get the results you're expecting.  

    SELECT title
    FROM films
    WHERE (release_year = 1994 OR release_year = 1995)
    AND (certification = 'PG' OR certification = 'R');

## BETWEEN keyword  

    SELECT title
    FROM films
    WHERE release_year >= 1994
    AND release_year <= 2000;

> Queries the titles of all films released in and between 1994 and 2000.  

    SELECT title
    FROM films
    WHERE release_year
    BETWEEN 1994 AND 2000;

> `BETWEEN` keyword provides a useful shorthand for filtering values within a specified range. This query is equivalent to the one above.  
> It's important to remember that `BETWEEN` is inclusive, meaning the beginning and end values are included in the results.  

## WHERE IN  
- If you want to filter based on many conditions, `WHERE` can get unwieldy.  
- The `IN` operator allows you to specify multiple values in a `WHERE` clause, making it easier and quicker to specify multiple `OR` conditions.  

    SELECT name
    FROM kids
    WHERE age = 2
    OR age = 4
    OR age = 6
    OR age = 8
    OR age = 10;

So, the above example would become:  

    SELECT name
    FROM kids
    WHERE age IN (2, 4, 6, 8, 10);

---

## Introduction to NULL and IS NULL  
- In SQL, `NULL` represents a missing or unknown value. You can check for `NULL` values using the expression `IS NULL`.  
- `IS NULL` is useful when combined with `WHERE` to figure out what data you're missing.  

    SELECT COUNT(*)
    FROM people
    WHERE birthdate IS NULL;

- Sometimes, you'll want to filter out missing values so you only get results which are not `NULL`. To do this, you can use the `IS NOT NULL` operator.  
For example, this query gives the names of all people whose birth dates are not missing in the people table.

    SELECT name
    FROM people
    WHERE birthdate IS NOT NULL;

## LIKE and NOT LIKE  
- As you've seen, the WHERE clause can be used to filter text data. However, so far you've only been able to filter by specifying the exact text you're interested in. In the real world, often you'll want to search for a pattern rather than a specific text string.  
- In SQL, the `LIKE` operator can be used in a `WHERE` clause to search for a pattern in a column. To accomplish this, you use something called a wildcard as a placeholder for some other values.  
- There are two wildcards you can use with `LIKE`: `%` wildcard will match zero, one, or many characters in text, the `_` wildcard will match a single character.  
- You can also use the `NOT LIKE` operator to find records that don't match the pattern you specify.  

    SELECT name
    FROM companies
    WHERE name LIKE 'Data%';

> Matches companies like 'Data', 'DataC' 'DataCamp', 'DataMind', and so on.  

    SELECT name
    FROM companies
    WHERE name LIKE 'DataC_mp';

> Matches companies like 'DataCamp', 'DataComp', and so on.  

---

## Aggregate functions  
- Often, you will want to perform some calculation on the data in a database. SQL provides a few functions, called aggregate functions, to help you out with this.  
- `AVG`, `MIN`, `MAX`, `SUM`.  
- In addition to using aggregate functions, you can perform basic arithmetic with symbols like +, -, *, and /.  

    SELECT AVG(budget)
    FROM films;

> Average value from the budget column of the films table.  

    SELECT MAX(budget)
    FROM films;

> Returns the highest budget.  

    SELECT SUM(budget)
    FROM films;

> Returns the result of adding up the numeric values in a column.  

## Combining aggregate functions with WHERE  
- Aggregate functions can be combined with the WHERE clause to gain further insights from your data.  

    SELECT SUM(budget)
    FROM films
    WHERE release_year >= 2010;

> Total budget of movies made in the year 2010 or later.  


    SELECT (4 * 3);
    SELECT (4 / 3);

> The second call gives a result of 1.  
> SQL assumes that if you divide an integer by an integer, you want to get an integer back. So be careful when dividing.  
> If you want more precision when dividing, you can add decimal places to your numbers.  

    SELECT (4.0 / 3.0);

## It's AS simple AS aliasing  
- You may have noticed in the first exercise of this chapter that the column name of your result was just the name of the function you used.  
- Aliasing simply means you assign a temporary name to something.  
- To alias, you use the `AS` keyword.  

    SELECT MAX(budget) AS max_budget, MAX(duration) AS max_duration
    FROM films;

## ORDER BY  
- In SQL, the `ORDER BY` keyword is used to sort results in ascending or descending order according to the values of one or more columns.  
- By default `ORDER BY` will sort in ascending order. If you want to sort the results in descending order, you can use the DESC keyword.  

    SELECT title
    FROM films
    ORDER BY release_year DESC;

> Gives you the titles of films sorted by release year, from newest to oldest.  

## GROUP BY  
- In SQL, `GROUP BY` allows you to group a result by one or more columns.  
- Commonly, `GROUP BY` is used with aggregate functions like `COUNT()` or `MAX()`. Note that `GROUP BY` always goes after the `FROM` clause.  
- Note that `ORDER BY` always goes after `GROUP BY`.  

    SELECT sex, count(*)
    FROM employees
    GROUP BY sex
    ORDER BY count DESC;

## HAVING keyword  
- In SQL, aggregate functions can't be used in `WHERE` clauses.  
- The following query is invalid.  

    SELECT release_year
    FROM films
    GROUP BY release_year
    WHERE COUNT(title) > 10;

The correct version:  

    SELECT release_year
    FROM films
    GROUP BY release_year
    HAVING COUNT(title) > 10;

> Shows only those years in which more than 10 films were released.  

---

## Inner join  
Although this course focuses on PostgreSQL, you'll find that these joins and the material here applies to different forms of SQL as well.
Throughout this course, you'll be working with the countries database containing information about the most populous world cities as well as country-level economic data, population data, and geographic data. This countries database also contains information on languages spoken in each country.
You can see the different tables in this database by clicking on the corresponding tabs. Click through them to get a sense for the types of data that each table contains before you continue with the course! Take note of the fields that appear to be shared across the tables.

Recall from the video the basic syntax for an INNER JOIN, here including all columns in both tables:

SELECT *
FROM left_table
INNER JOIN right_table
ON left_table.id = right_table.id;


Inner join (2)
Instead of writing the full table name, you can use table aliasing as a shortcut. For tables you also use AS to add the alias immediately after the table name with a space. Check out the aliasing of cities and countries below.

SELECT c1.name AS city, c2.name AS country
FROM cities AS c1
INNER JOIN countries AS c2
ON c1.country_code = c2.code;

Notice that to select a field in your query that appears in multiple tables, you'll need to identify which table/table alias you're referring to by using a . in your SELECT statement.
You'll now explore a way to get data from both the countries and economies tables to examine the inflation rate for both 2010 and 2015.
Sometimes it's easier to write SQL code out of order: you write the SELECT statement after you've done the JOIN.


Inner join (3)
The ability to combine multiple joins in a single query is a powerful feature of SQL, e.g:

SELECT *
FROM left_table
  INNER JOIN right_table
    ON left_table.id = right_table.id
  INNER JOIN another_table
    ON left_table.id = another_table.id;

As you can see here it becomes tedious to continually write long table names in joins. This is when it becomes useful to alias each table using the first letter of its name (e.g. countries AS c)! It is standard practice to alias in this way and, if you choose to alias tables or are asked specifically for an exercise in this course, you should follow this protocol.
Now, for each country, you want to get the country name, its region, the fertility rate, and the unemployment rate for both 2010 and 2015.
Note that results should work throughout this course with or without table aliasing unless specified differently.


Inner join with using
When joining tables with a common field name, e.g.

SELECT *
FROM countries
  INNER JOIN economies
    ON countries.code = economies.code

You can use USING as a shortcut:

SELECT *
FROM countries
  INNER JOIN economies
    USING(code)


Inner challenge
The table you created with the added geosize_group field has been loaded for you here with the name countries_plus. Observe the use of (and the placement of) the INTO command to create this countries_plus table:

SELECT name, continent, code, surface_area,
    CASE WHEN surface_area > 2000000
            THEN 'large'
       WHEN surface_area > 350000
            THEN 'medium'
       ELSE 'small' END
       AS geosize_group
INTO countries_plus
FROM countries;


Set theory clauses

Relating semi-join to a tweaked inner join
Let's revisit the code from the previous exercise, which retrieves languages spoken in the Middle East.

SELECT DISTINCT name
FROM languages
WHERE code IN
  (SELECT code
   FROM countries
   WHERE region = 'Middle East')
ORDER BY name;

Sometimes problems solved with semi-joins can also be solved using an inner join.

SELECT DISTINCT languages.name AS language
FROM languages
INNER JOIN countries
ON languages.code = countries.code
WHERE region = 'Middle East'
ORDER BY language;


Group by vs Subquery
-	These two pieces of code produce the same result
-	The subquery performs the same function as the GROUP BY statement
-	So you COUNT the number of cities and then group them into countries i.e. count variable x and group by variable y
-	Remember: the GROUP BY query only works if ‘country’ is included as a field in the SELECT clause as we are grouping by that field
-	Remember that you'll need to GROUP BY all fields that aren't included in the aggregate function of SELECT


SELECT countries.name AS country, COUNT(*) AS cities_num
 FROM cities
   INNER JOIN countries
   ON countries.code = cities.country_code
GROUP BY country
ORDER BY cities_num DESC, country
LIMIT 9;


SELECT countries.name AS country,
 -- Subquery
 (SELECT COUNT(*)
  FROM cities
  WHERE countries.code = cities.country_code) AS cities_num
FROM countries
ORDER BY cities_num DESC, country
LIMIT 9;


Final challenge 1
-	Subquery inside the ON statement
-	Matching data on two fields

-- Select fields
SELECT DISTINCT c.name, e.total_investment,e.imports
 -- From table (with alias)
 FROM countries AS c
   -- Join with table (with alias)
   LEFT JOIN economies AS e
     -- Match on code
     ON (c.code = e.code
     -- and code in Subquery
       AND c.code IN (
         SELECT l.code
         FROM languages AS l
         WHERE official = 'true'
       ))
 -- Where region and year are correct
 WHERE c.region = 'Central America' AND e.year = '2015'
-- Order by field
ORDER BY c.name;



Final challenge 3
Subquery in a subquery

-- Select fields
SELECT name, country_code, city_proper_pop, metroarea_pop, 
     -- Calculate city_perc
     city_proper_pop/metroarea_pop * 100 AS city_perc
 -- From appropriate table
 FROM cities
 -- Where
 WHERE name IN
   -- Subquery
   (SELECT capital
    FROM countries
    WHERE (continent = 'Europe'
       OR continent LIKE '%America'))
      AND metroarea_pop IS NOT NULL
-- Order appropriately
ORDER BY city_perc DESC
-- Limit amount
LIMIT 10;



INTERMEDIATE SQL

1. We’ll take the case

CASE WHEN is used when you want to perform multiple joins e.g. you want to compare data from a column in one table with data from 2 columns in another table
In this exercise, you will identify matches played between FC Schalke 04 and FC Bayern Munich. There are 2 teams identified in each match in the hometeam_id and awayteam_id columns, available to you in the filtered matches_germany table. ID can join to the team_api_id column in the teams_germany table, but you cannot perform a join on both at the same time.
However, you can perform this operation using a CASE statement once you've identified the team_api_id associated with each team!

-- Identify the home team as Bayern Munich, Schalke 04, or neither
SELECT
       CASE WHEN hometeam_id = 10189 THEN 'FC Schalke 04'
       WHEN hometeam_id = 9823 THEN 'FC Bayern Munich'
       ELSE 'Other' END AS home_team,
       COUNT(id) AS total_matches
FROM matches_germany
-- Group by the CASE statement alias
GROUP BY home_team;


In case of rivalry

SELECT
       date,
       CASE WHEN hometeam_id = 8634 THEN 'FC Barcelona'
        ELSE 'Real Madrid CF' END as home,
       CASE WHEN awayteam_id = 8634 THEN 'FC Barcelona'
        ELSE 'Real Madrid CF' END as away,
       -- Identify all possible match outcomes
       CASE WHEN home_goal > away_goal AND hometeam_id = 8634 THEN 'Barcelona win!'
       WHEN home_goal > away_goal AND hometeam_id = 8633 THEN 'Real Madrid win!'
       WHEN home_goal < away_goal AND awayteam_id = 8634 THEN 'Barcelona win!'
       WHEN home_goal < away_goal AND awayteam_id = 8633 THEN 'Real Madrid win!'
       ELSE 'Tie!' END AS outcome
FROM matches_spain
WHERE (awayteam_id = 8634 OR hometeam_id = 8634)
     AND (awayteam_id = 8633 OR hometeam_id = 8633);



Filtering your case statement
CASE statements allow you to categorize data that you're interested in -- and exclude data you're not interested in. In order to do this, you can use a CASE statement as a filter in the WHERE statement to remove output you don't want to see.

SELECT *
FROM table
WHERE 
    CASE WHEN a > 5 THEN 'Keep'
         WHEN a <= 5 THEN 'Exclude' END = 'Keep';
In essence, you can use the CASE statement as a filtering column like any other column in your database. The only difference is that you don't alias the statement in WHERE.

Use the CASE statement in the WHERE clause to filter all NULL values generated by the statement in the previous step.

-- Select the season, date, home_goal, and away_goal columns
SELECT
   season,
   date,
   home_goal,
   away_goal
FROM matches_italy
WHERE
-- Exclude games not won by Bologna
   CASE WHEN hometeam_id = 9857 AND home_goal > away_goal THEN 'Bologna Win'
        WHEN awayteam_id = 9857 AND away_goal > home_goal THEN 'Bologna Win'
        END IS NOT NULL;




Else values are NULL
These lines of code produce the same result i.e. produce null results where conditions are not met:
-	ELSE NULL END AS outcome
-	END AS outcome

SELECT
   c.name AS country,
   -- Count games from the 2012/2013 season
   COUNT(CASE WHEN m.season = '2012/2013'
              THEN m.id ELSE NULL END) AS matches_2012_2013
FROM country AS c
LEFT JOIN match AS m
ON c.id = m.country_id
-- Group by country name alias
GROUP BY country;


Else values are NOT NULL
END IS NOT NULL AS away_goals


COUNT and CASE WHEN with multiple conditions
In R or Python, you have the ability to calculate a SUM of logical values (i.e., TRUE/FALSE) directly. In SQL, you have to convert these values into 1 and 0 before calculating a sum. This can be done using a CASE statement.
There's one key difference when using SUM to aggregate logical values compared to using COUNT in the previous exercise --
Your goal here is to use the country and match table to determine the total number of matches won by the home team in each country during the 2012/2013, 2013/2014, and 2014/2015 seasons.

Calculating percent with CASE and AVG
CASE statements will return any value you specify in your THEN clause. This is an incredibly powerful tool for robust calculations and data manipulation when used in conjunction with an aggregate statement. One key task you can perform is using CASE inside an AVG function to calculate a percentage of information in your database.
Here's an example of how you set that up:
AVG(CASE WHEN condition_is_met THEN 1
         WHEN condition_is_not_met THEN 0 END)

With this approach, it's important to accurately specify which records count as 0, otherwise your calculations may not be correct!


Calculating % with CASE and AVG

SELECT
   c.name AS country,
   -- Round the percentage of tied games to 2 decimal points
   ROUND(AVG(CASE WHEN m.season='2013/2014' AND m.home_goal = m.away_goal      THEN 1
            WHEN m.season='2013/2014' AND m.home_goal != m.away_goal THEN 0
            END),2) AS pct_ties_2013_2014,
   ROUND(AVG(CASE WHEN m.season='2014/2015' AND m.home_goal = m.away_goal THEN 1
            WHEN m.season='2014/2015' AND m.home_goal != m.away_goal THEN 0
            END),2) AS pct_ties_2014_2015
FROM country AS c
LEFT JOIN matches AS m
ON c.id = m.country_id
GROUP BY country;



2. Short and simple subqueries

Filtering using scalar subqueries
Subqueries are incredibly powerful for performing complex filters and transformations. You can filter data based on single, scalar values using a subquery in ways you cannot by using WHERE statements or joins. Subqueries can also be used for more advanced manipulation of your data set. You will likely encounter subqueries in any real-world setting that uses relational databases.

Joining Subqueries in FROM
A subquery in FROM is an effective way of answering detailed questions that requires filtering or transforming data before including it in your final results.

The subquery below creates a new table that we alias as sub
SELECT
   -- Select country name and the count match IDs
   name AS country_name,
   COUNT(c.id) AS matches
FROM country AS c
-- Inner join the subquery onto country
-- Select the country id and match id columns
INNER JOIN (SELECT id, country_id
          FROM match
          -- Filter the subquery by matches with 10+ goals
          WHERE (home_goal + away_goal) >= 10) AS sub
ON c.id = sub.country_id
GROUP BY country_name;


Add a subquery to the SELECT clause
Subqueries in SELECT statements generate a single value that allow you to pass an aggregate value down a data frame. This is useful for performing calculations on data within your database.

Subqueries in Select for Calculations
Subqueries in SELECT are a useful way to create calculated columns in a query. A subquery in SELECT can be treated as a single numeric value to use in your calculations. When writing queries in SELECT, it's important to remember that filtering the main query does not filter the subquery -- and vice versa.


Subqueries in the SELECT, FROM & WHERE clauses

SELECT
   -- Select the stage and average goals from s
   s.stage,
   ROUND(s.avg_goals,2) AS avg_goal,
   -- Select the overall average for 2012/2013
   (SELECT AVG(home_goal + away_goal) FROM match WHERE season = '2012/2013') AS overall_avg
FROM
   -- Select the stage and average goals in 2012/2013 from match
   (SELECT
        stage,
        AVG(home_goal + away_goal) AS avg_goals
    FROM match
    WHERE season = '2012/2013'
    GROUP BY stage) AS s
WHERE
   -- Filter the main query using the subquery
   s.avg_goals > (SELECT AVG(home_goal + away_goal)
                   FROM match WHERE season = '2012/2013');



3. Correlated queries, nested queries, and common table expressions

Correlated subqueries are subqueries that reference one or more columns in the main query.

Correlated subqueries depend on information in the main query to run, and thus, cannot be executed on their own.

Can be used in place of INNER JOIN

Correlated subqueries are evaluated in SQL once per row of data retrieved - a process that takes a lot more computing power and time than a simple subquery.

Correlated subqueries are:
-	Dependent on the main query
-	Evaluated in loops (increases query runtime)

Highest scoring match for each country in each season
SELECT
   -- Select country ID, date, home, and away goals from match
   main.country_id,
   main.date,
   main.home_goal,
   main.away_goal
FROM match AS main
WHERE
   -- Filter for matches with the highest number of goals scored
   (home_goal + away_goal) =
       (SELECT MAX(sub.home_goal + sub.away_goal)
        FROM match AS sub
        WHERE main.country_id = sub.country_id
              AND main.season = sub.season);



Nested subqueries are subqueries inside of subqueries

EXTRACT MONTH from date - extracts the month from the date column

Nested simple subqueries
SELECT
-- Select the season and max goals scored in a match
   	season,
MAX(home_goal + away_goal) AS max_goals,
  	-- Select the overall max goals scored in a match
  	(SELECT MAX(home_goal + away_goal) FROM match) AS overall_max_goals,

  	-- Select the max number of goals scored in any match in July
  	(SELECT MAX(home_goal + away_goal)
   	FROM match
   	WHERE id IN (
         SELECT id FROM match WHERE EXTRACT(MONTH FROM date) = 07)) AS july_max_goals
FROM match
GROUP BY season;


Season	max_goals	overall_max_goals	july_max_goals
2013/2014	10	11	7
2012/2013	11	11	7
2014/2015	10	11	7
2011/2012	10	11	7

The first MAX statement selects the max of goals by each season. The second MAX statement selects the overall max of goals (not just by season). As can be seen the highest goals across all seasons occurred in 2012/2013. The third MAX statement selects max goals in July 


Common table expressions (CTEs)
Used to neaten/organize subqueries by aliasing all subqueries prior to starting the main query. Then in the main query instead of writing out the full subquery you can call the alias name.

CTEs are executed once, which improves efficiency.

If you have multiple CTEs, they can reference one another i.e. the second CTE can reference the first CTE.

-- Set up your CTE
WITH match_list AS (
   SELECT
     country_id,
      (home_goal + away_goal) AS goals
   FROM match
   -- Create a list of match IDs to filter data in the CTE
   WHERE season = '2013/2014' AND EXTRACT(MONTH FROM date) = 08)

-- Select the league name and average of goals in the CTE
SELECT
 name,
   AVG(goals)
FROM league AS l
-- Join the CTE onto the league table
LEFT JOIN match_list
ON l.id = match_list.country_id
GROUP BY l.name;



When to use which type of query technique

Joins: (2+ tables) - what is the total sales per employee?
Correlated subqueries: who does each employee report to in a company?
Multiple/nested subqueries: what is the average deal size closed by each employee during the quarter?
Common table expressions: How did the marketing, sales, growth & engineering teams perform during the quarter?




How do you get both the home and away team names into one final query result?

1. Using subqueries

SELECT
 m.date,
   -- Get the home and away team names
   hometeam,
   awayteam,
   m.home_goal,
   m.away_goal
FROM match AS m

-- Join the home subquery to the match table
-- This block of code links the hometeam_id (table where home team IDs are stored) to the team_api_id (table where home team names are stored) in order to produce the actual names of the hometeams (and not just their IDs). The match.id column is selected as this will be used to join this new table ‘home’ to the main table ‘match’. Remember, in this new table ‘home’ the match.id column is only those IDs that relate to home teams based on the ON statement.
LEFT JOIN (
 SELECT match.id, team.team_long_name AS hometeam
 FROM match
 LEFT JOIN team
 ON match.hometeam_id = team.team_api_id) AS home

ON home.id = m.id

-- Join the away subquery to the match table
LEFT JOIN (
 SELECT match.id, team.team_long_name AS awayteam
 FROM match
 LEFT JOIN team
 -- Get the away team ID in the subquery
 ON match.awayteam_id = team.team_api_id) AS away
ON away.id = m.id;


2. Correlated subqueries
The inner query is linked to the outer query in the WHERE statement

SELECT
   m.date,
   (SELECT team_long_name
    FROM team AS t
    WHERE t.team_api_id = m.hometeam_id) AS hometeam,
   -- Connect the team to the match table
   (SELECT team_long_name
    FROM team AS t
    WHERE team_api_id = awayteam_id) AS awayteam,
   -- Select home and away goals
   home_goal,
   away_goal
FROM match AS m;


3. Common Table Expression (CTE)
In each of the two CTEs below, m.id (which is the match id i.e. it relates to a single match between a home and away team) is SELECTed as this will be used in the final INNER JOIN at the end of the query to join both tables.

WITH home AS (
 SELECT m.id, m.date,
      t.team_long_name AS hometeam, m.home_goal
 FROM match AS m
 LEFT JOIN team AS t
 ON m.hometeam_id = t.team_api_id),

-- Declare and set up the away CTE
away AS (
 SELECT m.id, m.date,
      t.team_long_name AS awayteam, m.away_goal
 FROM match AS m
 LEFT JOIN team AS t
 ON m.awayteam_id = t.team_api_id)

-- Select date, home_goal, and away_goal
SELECT
 home.date,
   home.hometeam,
   away.awayteam,
   home.home_goal,
   away.away_goal

-- Join away and home on the id column
FROM home
INNER JOIN away
ON home.id = away.id;
4. Window functions

Window functions solve the problem of having to GROUP BY all columns in the SELECT statement that are not in the aggregate function/s.

Can perform aggregate functions without having to group data.

The OVER() clause allows you to pass an aggregate function down a data set, similar to subqueries in SELECT. The OVER() clause offers significant benefits over subqueries in select -- namely, your queries will run faster, and the OVER() clause has a wide range of additional functions and clauses you can include with it.

OVER() - tells SQL to pass this aggregate value over the existing results set

AVG(home_goal + away_goal) OVER() AS overall_avg


Rank data
Window functions allow you to create a RANK of information according to any variable you want to use to sort your data. When setting this up, you will need to specify what column/calculation you want to use to calculate your rank. This is done by including an ORDER BY clause inside the OVER() clause. Below is an example:

SELECT 
    id,
    RANK() OVER(ORDER BY home_goal) AS rank
FROM match;

RANK() OVER(ORDER BY AVG(home_goal + away_goal) DESC) AS league_rank


Window partitions
Partitions allow you to formulate calculations partitioned by specified variable/s

AVG(home_goal) OVER(PARTITION BY season) AS avg_season - creates a separate column avg_season that calculates the average home goal for the season to which that row of data belongs

You can also partition by multiple data points at the same time

AVG(home_goal) OVER(PARTITION BY season, month) AS avg_season


Sliding windows
Sliding windows allows you to create running calculations between any two points in a window i.e. running totals, sums, count and averages.

Can also be partitioned by one or more columns

ROWS BETWEEN <start> AND <finish>

The following can be inserted into <start> and/or <finish>:
PRECEDING - specify the number of rows before the current row e.g. 1 PRECEDING refers to the previous row
FOLLOWING - specify the number of rows after the current row
UNBOUNDED PRECEDING - include every row since the beginning of the data set
UNBOUNDED FOLLOWING - include every row until the end of the data set
CURRENT ROW - tells SQL that you want to stop your calculation at the current row

SUM(home_goal) OVER(ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total,
   AVG(home_goal) OVER(ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg



POSTGRESQL SUMMARY STATS AND WINDOW FUNCTIONS

1. Introduction to window functions
Similar to GROUP BY functions, but all rows remain in the output
Use cases:
-	Fetch data from preceding or proceeding row (sliding windows)
-	Assigning ranks (rank data)
-	Running total, moving averages (sliding windows)


The OVER() clause indicates that the function is a window function
FUNCTION NAME () OVER(...)
●	ORDER BY
●	PARTITION BY
●	ROWS/RANGE PRECEDING/FOLLOWING/UNBOUNDED


SELECT
 *,
 -- Assign numbers to each row
 ROW_NUMBER() OVER() AS Row_N
FROM Summer_Medals
ORDER BY Row_N ASC;


Order by
Orders the rows relative to the current row
You can ORDER BY() both inside OVER() and outside:
●	ORDER BY() inside OVER() takes effect before ORDER BY() outside OVER()

Ranking Olympic Athletes by Medals Earned
Row numbering can also be used for ranking. For example, numbering rows and ordering by the count of medals each athlete earned in the OVER clause will assign 1 to the highest-earning medalist, 2 to the second highest-earning medalist, and so on. Use ROW_NUMBER()
WITH Athlete_Medals AS (
 SELECT
   -- Count the number of medals each athlete has earned
   Athlete,
   COUNT(*) AS Medals
 FROM Summer_Medals
 GROUP BY Athlete)

SELECT
 -- Number each athlete by how many medals they've earned
 athlete,
 ROW_NUMBER() OVER (ORDER BY medals DESC) AS Row_N
FROM Athlete_Medals
ORDER BY Medals DESC;



Reigning Olympic champion
A reigning champion is a champion who's won both the previous and current years' competitions. To determine if a champion is reigning, the previous and current years' results need to be in the same row, in two different columns. Use LAG() which fetches a row’s previous value
WITH Weightlifting_Gold AS (
 SELECT
   -- Return each year's champions' countries
   Year,
   Country AS champion
 FROM Summer_Medals
 WHERE
   Discipline = 'Weightlifting' AND
   Event = '69KG' AND
   Gender = 'Men' AND
   Medal = 'Gold')

SELECT
 Year, Champion,
 -- Fetch the previous year's champion
 LAG(champion,1) OVER
   (ORDER BY Year ASC) AS Last_Champion
FROM Weightlifting_Gold
ORDER BY Year ASC;


Partition by
●	Splits a table into partitions based on a column’s unique values
○	SQL logic treats each partition as a separate table but the actual table isn’t split
●	This means ROW_NUMBER() will reset for each partition
●	LAG() will fetch the value in the previous row of that particular partition

WITH Athletics_Gold AS (
 SELECT DISTINCT
   Gender, Year, Event, Country
 FROM Summer_Medals
 WHERE
   Year >= 2000 AND
   Discipline = 'Athletics' AND
   Event IN ('100M', '10000M') AND
   Medal = 'Gold')

SELECT
 Gender, Year, Event,
 Country AS Champion,
 -- Fetch the previous year's champion by gender and event
 LAG(Country,1) OVER (PARTITION BY gender, event
           ORDER BY Year ASC) AS Last_Champion
FROM Athletics_Gold
ORDER BY Event ASC, Gender ASC, Year ASC;
2. Fetching, ranking and paging

Fetching
4 types:
●	Relative:
○	LAG(column, n): returns column value at n rows before current row
○	LEAD(column, n): returns column value at n rows after current row
●	Absolute:
○	FIRST_VALUE(column): returns the first value in the table or partition
○	LAST_VALUE(column): returns the last value in the table or partition

Note
By default, a window starts at the beginning of the table, or partition, and ends at the current row
●	For LAST_VALUE(column) we need to modify the code as follows:
○	LAST_VALUE(column) OVER(RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
■	This extends the window the end of the table/partition


Ranking
●	ROW_NUMBER() - assigns unique numbers to every row regardless of whether the values are equal
●	RANK() - all rows with the same value will receive an equal rank, skipping over the next number in such cases
●	DENSE_RANK() - also assigns the same rank to equal rows, but doesn’t skip over the next numbers

Note
●	ROW_NUMBER() and RANK() will always have the same last rank (which is the number of rows)
●	DENSE_RANK()’s last rank will display the total number of unique values being ranked
 


Paging
Splitting data into (approximately) equal chunks. The split will only be equal if the total number of rows is divisible by the number of pages you are wanting to split into.
Use cases:
●	APIs return data in ‘pages’ to reduce the size of data being sent
●	Separate data into quartiles

NTILE(n) - splits data into n chunks

WITH Athlete_Medals AS (
 SELECT Athlete, COUNT(*) AS Medals
 FROM Summer_Medals
 GROUP BY Athlete
 HAVING COUNT(*) > 1),
  
Thirds AS (
 SELECT
   Athlete,
   Medals,
   NTILE(3) OVER (ORDER BY Medals DESC) AS Third
 FROM Athlete_Medals)

 SELECT
 -- Get the average medals earned in each third
 Third,
 AVG(medals) AS Avg_Medals
FROM Thirds
GROUP BY Third
ORDER BY Third ASC;

 



3. Aggregate window functions and frames

Aggregate window functions
MAX, MIN, COUNT, AVG and SUM, are aggregate functions normally used with GROUP BY. These can also be used as window functions.

The running total (or cumulative sum) of a column helps you determine what each row's contribution is to the total sum.
SELECT
 -- Calculate the running total of athlete medals
 Athlete,
 Medals,
 SUM (Medals) OVER (ORDER BY Athlete ASC) AS Max_Medals
FROM Athlete_Medals
ORDER BY Athlete ASC;

 

Getting the maximum of a country's earned medals so far helps you determine whether a country has broken its medals record by comparing the current year's earned medals and the maximum so far.
SELECT
 -- Return the max medals earned so far per country
 Year,
 Country,
 Medals,
 Max(Medals) OVER (PARTITION BY Country
               ORDER BY Year ASC) AS Max_Medals
FROM Country_Medals
ORDER BY Country ASC, Year ASC;
 



Frames (sliding windows)
Allow you to restrict the rows passed as input to your window function to a sliding window for you to define the start and finish. Adding a frame to your window function allows you to calculate "moving" metrics, inputs of which slide from row to row.

Use:
●	ROWS BETWEEN <start> AND <finish>
●	RANGE BETWEEN <start> AND <finish>

The following can be inserted into <start> and/or <finish>:
Note: comes after the ORDER BY clause

●	PRECEDING - specify the number of rows before the current row e.g. 1 PRECEDING refers to the previous row
●	FOLLOWING - specify the number of rows after the current row
●	UNBOUNDED PRECEDING - include every row since the beginning of the data set
●	UNBOUNDED FOLLOWING - include every row until the end of the data set
●	CURRENT ROW - tells SQL that you want to stop your calculation at the current row

 


Moving averages and totals
AVG() and SUM()

Difference of:
●	ROWS BETWEEN <start> AND <finish>
●	RANGE BETWEEN <start> AND <finish>
○	Treat’s duplicates in OVER’s ORDER BY sub clause as a single entity
○	RANGE is not used often in practice.

Medals earned per year
Rows_RT and Range_RT are running totals
●	Range_RT treats the rows with duplicate values as single rows
●	Range_RT groups all similar data together and performs the function on them one time i.e. when it comes across the 50 medals in 1996 it also knows there are 50 medals in 2000 and so it sums them up already in row 2 and adds 100 to Range_RT 
 
Moving totals of countries’ medals

SELECT
 Year, Country, Medals,
 -- Calculate each country's 3-game moving total
 SUM (Medals) OVER
   (PARTITION BY Country
    ORDER BY Year ASC
    ROWS BETWEEN
    2 PRECEDING AND CURRENT ROW) AS Medals_MA
FROM Country_Medals
ORDER BY Country ASC, Year ASC;

 



4. Beyond window functions

Pivoting
Use CROSSTAB
But first we need to write the following: CREATE EXTENSION IF NOT EXISTS tablefunc
●	CREATE EXTENSION makes extra functions available
●	The tablefunc extension contains the CROSSTAB function

CREATE EXTENSION IF NOT EXISTS tablefunc;
SELECT * 
FROM CROSSTAB($$ # the original query goes after the $$
  source_sql TEXT
$$) AS ct (column_1 DATA_TYPE_1, # column names and types of the new pivoted column
           column_2 DATA_TYPE_2,
           ...,
           column_n DATA_TYPE_N);

Example
CREATE EXTENSION IF NOT EXISTS tablefunc;

SELECT * FROM CROSSTAB($$
 WITH Country_Awards AS (
   SELECT
     Country,
     Year,
     COUNT(*) AS Awards
   FROM Summer_Medals
   WHERE
     Country IN ('FRA', 'GBR', 'GER')
     AND Year IN (2004, 2008, 2012)
     AND Medal = 'Gold'
   GROUP BY Country, Year)

 SELECT
   Country,
   Year,
   RANK() OVER
     (PARTITION BY Year
      ORDER BY Awards DESC) :: INTEGER AS rank
 FROM Country_Awards
 ORDER BY Country ASC, Year ASC;
-- Fill in the correct column names for the pivoted table
$$) AS ct (Country VARCHAR,
          "2004" INTEGER,
          "2008" INTEGER,
          "2012" INTEGER)

Order by Country ASC;

 



ROLLUP and CUBE
●	Used to calculate group level totals within a data set as well as grand totals
●	ROLLUP is a GROUP BY sub clause that includes extra rows for group-level aggregations
●	The order in which columns are rolled up matters
●	CUBE is the same as ROLLUP except that order doesn’t matter i.e. it is not hierarchical
●	Whatever column is included in the brackets of ROLLUP or CUBE is what is being counted

ROLLUP example
-- Count the gold medals per country and gender
SELECT
 country,
 gender,
 COUNT(*) AS Gold_Awards
FROM Summer_Medals
WHERE
 Year = 2004
 AND Medal = 'Gold'
 AND Country IN ('DEN', 'NOR', 'SWE')
-- Generate Country-level subtotals
GROUP BY country, rollup(gender)
ORDER BY Country ASC, Gender ASC;


Result
●	The rows titled ‘null’ are where the totals are located
●	Counting the number of medals for men and women by country
 

CUBE example
-- Count the gold medals per country and gender
SELECT
 country,
 gender,
 COUNT(*) AS Gold_Awards
FROM Summer_Medals
WHERE
 Year = 2004
 AND Medal = 'Gold'
 AND Country IN ('DEN', 'NOR', 'SWE')
-- Generate Country-level subtotals
GROUP BY country, rollup(gender)
ORDER BY Country ASC, Gender ASC;

Result
●	Calculates all possible totals both grouped by gender and medal
●	The row at the end with all nulls is the grand total
 


A survey of useful functions
COALESCE()
●	Takes a list of values and returns the first non-null value, going from left to right
●	Useful for:
○	ROLLUP and CUBE
○	Pivoting
○	LAG and LEAD (as these produce null values in the first and last rows respectively)

COALESCE() example
SELECT
 -- Replace the nulls in the columns with meaningful text
 COALESCE(Country, 'All countries') AS Country,
 COALESCE(Gender, 'All genders') AS Gender,
 COUNT(*) AS Awards
FROM Summer_Medals
WHERE
 Year = 2004
 AND Medal = 'Gold'
 AND Country IN ('DEN', 'NOR', 'SWE')
GROUP BY ROLLUP(Country, Gender)
ORDER BY Country ASC, Gender ASC;


Result
●	‘All genders’ is the total for each country
●	‘All countries’ is the grand total
 

Compressing data
●	When using Rank the actual rank column becomes redundant as the order implies the rank
●	STRING_AGG(column, separator)
●	Useful when you want to reduce the number of rows returned

Example
WITH Country_Medals AS (
 SELECT
   Country,
   COUNT(*) AS Medals
 FROM Summer_Medals
 WHERE Year = 2000
   AND Medal = 'Gold'
 GROUP BY Country),

 Country_Ranks AS (
 SELECT
   Country,
   RANK() OVER (ORDER BY Medals DESC) AS Rank
 FROM Country_Medals
 ORDER BY Rank ASC)

-- Compress the countries column
SELECT STRING_AGG(country,', ')
FROM Country_Ranks
-- Select only the top three ranks
WHERE rank <= 3;


Result
●	Select the top 3 countries with the highest rank i.e. a rank <= 3 (with 1 being the highest rank)
 

Joins
INNER JOIN
LEFT JOIN
RIGHT JOIN
FULL JOIN
Semi join and anti join - similar to subqueries

Set theory clauses
UNION - unique
UNION ALL - double counts
INTERSECT - present in both tables
EXCEPT - only records found in one table but not the other

Subqueries

Comments
/* THIS IS A COMMENT */
-- TWO DASHES REPRESENT INLINE COMMENTS